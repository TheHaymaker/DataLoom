// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: logicExample.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "LogicExample";

/** Supported comparison operators */
export enum ComparisonOperator {
  EQUALS = 0,
  NOT_EQUALS = 1,
  GREATER_THAN = 2,
  LESS_THAN = 3,
  CONTAINS = 4,
  STARTS_WITH = 5,
  ENDS_WITH = 6,
  UNRECOGNIZED = -1,
}

export function comparisonOperatorFromJSON(object: any): ComparisonOperator {
  switch (object) {
    case 0:
    case "EQUALS":
      return ComparisonOperator.EQUALS;
    case 1:
    case "NOT_EQUALS":
      return ComparisonOperator.NOT_EQUALS;
    case 2:
    case "GREATER_THAN":
      return ComparisonOperator.GREATER_THAN;
    case 3:
    case "LESS_THAN":
      return ComparisonOperator.LESS_THAN;
    case 4:
    case "CONTAINS":
      return ComparisonOperator.CONTAINS;
    case 5:
    case "STARTS_WITH":
      return ComparisonOperator.STARTS_WITH;
    case 6:
    case "ENDS_WITH":
      return ComparisonOperator.ENDS_WITH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ComparisonOperator.UNRECOGNIZED;
  }
}

export function comparisonOperatorToJSON(object: ComparisonOperator): string {
  switch (object) {
    case ComparisonOperator.EQUALS:
      return "EQUALS";
    case ComparisonOperator.NOT_EQUALS:
      return "NOT_EQUALS";
    case ComparisonOperator.GREATER_THAN:
      return "GREATER_THAN";
    case ComparisonOperator.LESS_THAN:
      return "LESS_THAN";
    case ComparisonOperator.CONTAINS:
      return "CONTAINS";
    case ComparisonOperator.STARTS_WITH:
      return "STARTS_WITH";
    case ComparisonOperator.ENDS_WITH:
      return "ENDS_WITH";
    case ComparisonOperator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum NotificationLevel {
  INFO = 0,
  WARNING = 1,
  ERROR = 2,
  UNRECOGNIZED = -1,
}

export function notificationLevelFromJSON(object: any): NotificationLevel {
  switch (object) {
    case 0:
    case "INFO":
      return NotificationLevel.INFO;
    case 1:
    case "WARNING":
      return NotificationLevel.WARNING;
    case 2:
    case "ERROR":
      return NotificationLevel.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NotificationLevel.UNRECOGNIZED;
  }
}

export function notificationLevelToJSON(object: NotificationLevel): string {
  switch (object) {
    case NotificationLevel.INFO:
      return "INFO";
    case NotificationLevel.WARNING:
      return "WARNING";
    case NotificationLevel.ERROR:
      return "ERROR";
    case NotificationLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents a logical condition that can be evaluated */
export interface Condition {
  comparison?: ComparisonCondition | undefined;
  and?: AndCondition | undefined;
  or?: OrCondition | undefined;
  not?: NotCondition | undefined;
  exists?: ExistsCondition | undefined;
}

/** Represents a comparison between a field and a value */
export interface ComparisonCondition {
  field: string;
  operator: ComparisonOperator;
  value: Value | undefined;
}

/** Represents a logical AND of multiple conditions */
export interface AndCondition {
  conditions: Condition[];
}

/** Represents a logical OR of multiple conditions */
export interface OrCondition {
  conditions: Condition[];
}

/** Represents a logical NOT of a condition */
export interface NotCondition {
  condition: Condition | undefined;
}

/** Represents checking if a field exists */
export interface ExistsCondition {
  field: string;
}

/** Represents different types of values that can be compared */
export interface Value {
  stringValue?: string | undefined;
  intValue?: number | undefined;
  boolValue?: boolean | undefined;
  doubleValue?: number | undefined;
}

/** Example usage: Rule for processing a user action */
export interface ProcessingRule {
  name: string;
  condition: Condition | undefined;
  action: Action | undefined;
}

/** Actions to take when a condition is met */
export interface Action {
  transform?: TransformAction | undefined;
  notify?: NotifyAction | undefined;
  validate?: ValidateAction | undefined;
}

export interface TransformAction {
  field: string;
  transformation: string;
}

export interface NotifyAction {
  message: string;
  level: NotificationLevel;
}

export interface ValidateAction {
  validationRule: string;
  errorMessage: string;
}

function createBaseCondition(): Condition {
  return { comparison: undefined, and: undefined, or: undefined, not: undefined, exists: undefined };
}

export const Condition: MessageFns<Condition> = {
  encode(message: Condition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.comparison !== undefined) {
      ComparisonCondition.encode(message.comparison, writer.uint32(10).fork()).join();
    }
    if (message.and !== undefined) {
      AndCondition.encode(message.and, writer.uint32(18).fork()).join();
    }
    if (message.or !== undefined) {
      OrCondition.encode(message.or, writer.uint32(26).fork()).join();
    }
    if (message.not !== undefined) {
      NotCondition.encode(message.not, writer.uint32(34).fork()).join();
    }
    if (message.exists !== undefined) {
      ExistsCondition.encode(message.exists, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Condition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.comparison = ComparisonCondition.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.and = AndCondition.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.or = OrCondition.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.not = NotCondition.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.exists = ExistsCondition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Condition {
    return {
      comparison: isSet(object.comparison) ? ComparisonCondition.fromJSON(object.comparison) : undefined,
      and: isSet(object.and) ? AndCondition.fromJSON(object.and) : undefined,
      or: isSet(object.or) ? OrCondition.fromJSON(object.or) : undefined,
      not: isSet(object.not) ? NotCondition.fromJSON(object.not) : undefined,
      exists: isSet(object.exists) ? ExistsCondition.fromJSON(object.exists) : undefined,
    };
  },

  toJSON(message: Condition): unknown {
    const obj: any = {};
    if (message.comparison !== undefined) {
      obj.comparison = ComparisonCondition.toJSON(message.comparison);
    }
    if (message.and !== undefined) {
      obj.and = AndCondition.toJSON(message.and);
    }
    if (message.or !== undefined) {
      obj.or = OrCondition.toJSON(message.or);
    }
    if (message.not !== undefined) {
      obj.not = NotCondition.toJSON(message.not);
    }
    if (message.exists !== undefined) {
      obj.exists = ExistsCondition.toJSON(message.exists);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Condition>, I>>(base?: I): Condition {
    return Condition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Condition>, I>>(object: I): Condition {
    const message = createBaseCondition();
    message.comparison = (object.comparison !== undefined && object.comparison !== null)
      ? ComparisonCondition.fromPartial(object.comparison)
      : undefined;
    message.and = (object.and !== undefined && object.and !== null) ? AndCondition.fromPartial(object.and) : undefined;
    message.or = (object.or !== undefined && object.or !== null) ? OrCondition.fromPartial(object.or) : undefined;
    message.not = (object.not !== undefined && object.not !== null) ? NotCondition.fromPartial(object.not) : undefined;
    message.exists = (object.exists !== undefined && object.exists !== null)
      ? ExistsCondition.fromPartial(object.exists)
      : undefined;
    return message;
  },
};

function createBaseComparisonCondition(): ComparisonCondition {
  return { field: "", operator: 0, value: undefined };
}

export const ComparisonCondition: MessageFns<ComparisonCondition> = {
  encode(message: ComparisonCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.operator !== 0) {
      writer.uint32(16).int32(message.operator);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComparisonCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComparisonCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operator = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComparisonCondition {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      operator: isSet(object.operator) ? comparisonOperatorFromJSON(object.operator) : 0,
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ComparisonCondition): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.operator !== 0) {
      obj.operator = comparisonOperatorToJSON(message.operator);
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComparisonCondition>, I>>(base?: I): ComparisonCondition {
    return ComparisonCondition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComparisonCondition>, I>>(object: I): ComparisonCondition {
    const message = createBaseComparisonCondition();
    message.field = object.field ?? "";
    message.operator = object.operator ?? 0;
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseAndCondition(): AndCondition {
  return { conditions: [] };
}

export const AndCondition: MessageFns<AndCondition> = {
  encode(message: AndCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conditions) {
      Condition.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AndCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAndCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conditions.push(Condition.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AndCondition {
    return {
      conditions: globalThis.Array.isArray(object?.conditions)
        ? object.conditions.map((e: any) => Condition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AndCondition): unknown {
    const obj: any = {};
    if (message.conditions?.length) {
      obj.conditions = message.conditions.map((e) => Condition.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AndCondition>, I>>(base?: I): AndCondition {
    return AndCondition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AndCondition>, I>>(object: I): AndCondition {
    const message = createBaseAndCondition();
    message.conditions = object.conditions?.map((e) => Condition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOrCondition(): OrCondition {
  return { conditions: [] };
}

export const OrCondition: MessageFns<OrCondition> = {
  encode(message: OrCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conditions) {
      Condition.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conditions.push(Condition.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrCondition {
    return {
      conditions: globalThis.Array.isArray(object?.conditions)
        ? object.conditions.map((e: any) => Condition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OrCondition): unknown {
    const obj: any = {};
    if (message.conditions?.length) {
      obj.conditions = message.conditions.map((e) => Condition.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrCondition>, I>>(base?: I): OrCondition {
    return OrCondition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrCondition>, I>>(object: I): OrCondition {
    const message = createBaseOrCondition();
    message.conditions = object.conditions?.map((e) => Condition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNotCondition(): NotCondition {
  return { condition: undefined };
}

export const NotCondition: MessageFns<NotCondition> = {
  encode(message: NotCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.condition !== undefined) {
      Condition.encode(message.condition, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.condition = Condition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotCondition {
    return { condition: isSet(object.condition) ? Condition.fromJSON(object.condition) : undefined };
  },

  toJSON(message: NotCondition): unknown {
    const obj: any = {};
    if (message.condition !== undefined) {
      obj.condition = Condition.toJSON(message.condition);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotCondition>, I>>(base?: I): NotCondition {
    return NotCondition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotCondition>, I>>(object: I): NotCondition {
    const message = createBaseNotCondition();
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? Condition.fromPartial(object.condition)
      : undefined;
    return message;
  },
};

function createBaseExistsCondition(): ExistsCondition {
  return { field: "" };
}

export const ExistsCondition: MessageFns<ExistsCondition> = {
  encode(message: ExistsCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExistsCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExistsCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExistsCondition {
    return { field: isSet(object.field) ? globalThis.String(object.field) : "" };
  },

  toJSON(message: ExistsCondition): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExistsCondition>, I>>(base?: I): ExistsCondition {
    return ExistsCondition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExistsCondition>, I>>(object: I): ExistsCondition {
    const message = createBaseExistsCondition();
    message.field = object.field ?? "";
    return message;
  },
};

function createBaseValue(): Value {
  return { stringValue: undefined, intValue: undefined, boolValue: undefined, doubleValue: undefined };
}

export const Value: MessageFns<Value> = {
  encode(message: Value, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stringValue !== undefined) {
      writer.uint32(10).string(message.stringValue);
    }
    if (message.intValue !== undefined) {
      writer.uint32(16).int32(message.intValue);
    }
    if (message.boolValue !== undefined) {
      writer.uint32(24).bool(message.boolValue);
    }
    if (message.doubleValue !== undefined) {
      writer.uint32(33).double(message.doubleValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Value {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.intValue = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.doubleValue = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Value {
    return {
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      intValue: isSet(object.intValue) ? globalThis.Number(object.intValue) : undefined,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      doubleValue: isSet(object.doubleValue) ? globalThis.Number(object.doubleValue) : undefined,
    };
  },

  toJSON(message: Value): unknown {
    const obj: any = {};
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.intValue !== undefined) {
      obj.intValue = Math.round(message.intValue);
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.doubleValue !== undefined) {
      obj.doubleValue = message.doubleValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Value>, I>>(base?: I): Value {
    return Value.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Value>, I>>(object: I): Value {
    const message = createBaseValue();
    message.stringValue = object.stringValue ?? undefined;
    message.intValue = object.intValue ?? undefined;
    message.boolValue = object.boolValue ?? undefined;
    message.doubleValue = object.doubleValue ?? undefined;
    return message;
  },
};

function createBaseProcessingRule(): ProcessingRule {
  return { name: "", condition: undefined, action: undefined };
}

export const ProcessingRule: MessageFns<ProcessingRule> = {
  encode(message: ProcessingRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.condition !== undefined) {
      Condition.encode(message.condition, writer.uint32(18).fork()).join();
    }
    if (message.action !== undefined) {
      Action.encode(message.action, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessingRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessingRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.condition = Condition.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = Action.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessingRule {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      condition: isSet(object.condition) ? Condition.fromJSON(object.condition) : undefined,
      action: isSet(object.action) ? Action.fromJSON(object.action) : undefined,
    };
  },

  toJSON(message: ProcessingRule): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.condition !== undefined) {
      obj.condition = Condition.toJSON(message.condition);
    }
    if (message.action !== undefined) {
      obj.action = Action.toJSON(message.action);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessingRule>, I>>(base?: I): ProcessingRule {
    return ProcessingRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessingRule>, I>>(object: I): ProcessingRule {
    const message = createBaseProcessingRule();
    message.name = object.name ?? "";
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? Condition.fromPartial(object.condition)
      : undefined;
    message.action = (object.action !== undefined && object.action !== null)
      ? Action.fromPartial(object.action)
      : undefined;
    return message;
  },
};

function createBaseAction(): Action {
  return { transform: undefined, notify: undefined, validate: undefined };
}

export const Action: MessageFns<Action> = {
  encode(message: Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transform !== undefined) {
      TransformAction.encode(message.transform, writer.uint32(10).fork()).join();
    }
    if (message.notify !== undefined) {
      NotifyAction.encode(message.notify, writer.uint32(18).fork()).join();
    }
    if (message.validate !== undefined) {
      ValidateAction.encode(message.validate, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transform = TransformAction.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.notify = NotifyAction.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.validate = ValidateAction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action {
    return {
      transform: isSet(object.transform) ? TransformAction.fromJSON(object.transform) : undefined,
      notify: isSet(object.notify) ? NotifyAction.fromJSON(object.notify) : undefined,
      validate: isSet(object.validate) ? ValidateAction.fromJSON(object.validate) : undefined,
    };
  },

  toJSON(message: Action): unknown {
    const obj: any = {};
    if (message.transform !== undefined) {
      obj.transform = TransformAction.toJSON(message.transform);
    }
    if (message.notify !== undefined) {
      obj.notify = NotifyAction.toJSON(message.notify);
    }
    if (message.validate !== undefined) {
      obj.validate = ValidateAction.toJSON(message.validate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action>, I>>(base?: I): Action {
    return Action.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action>, I>>(object: I): Action {
    const message = createBaseAction();
    message.transform = (object.transform !== undefined && object.transform !== null)
      ? TransformAction.fromPartial(object.transform)
      : undefined;
    message.notify = (object.notify !== undefined && object.notify !== null)
      ? NotifyAction.fromPartial(object.notify)
      : undefined;
    message.validate = (object.validate !== undefined && object.validate !== null)
      ? ValidateAction.fromPartial(object.validate)
      : undefined;
    return message;
  },
};

function createBaseTransformAction(): TransformAction {
  return { field: "", transformation: "" };
}

export const TransformAction: MessageFns<TransformAction> = {
  encode(message: TransformAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.transformation !== "") {
      writer.uint32(18).string(message.transformation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransformAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransformAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transformation = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransformAction {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      transformation: isSet(object.transformation) ? globalThis.String(object.transformation) : "",
    };
  },

  toJSON(message: TransformAction): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.transformation !== "") {
      obj.transformation = message.transformation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransformAction>, I>>(base?: I): TransformAction {
    return TransformAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransformAction>, I>>(object: I): TransformAction {
    const message = createBaseTransformAction();
    message.field = object.field ?? "";
    message.transformation = object.transformation ?? "";
    return message;
  },
};

function createBaseNotifyAction(): NotifyAction {
  return { message: "", level: 0 };
}

export const NotifyAction: MessageFns<NotifyAction> = {
  encode(message: NotifyAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.level !== 0) {
      writer.uint32(16).int32(message.level);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.level = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotifyAction {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      level: isSet(object.level) ? notificationLevelFromJSON(object.level) : 0,
    };
  },

  toJSON(message: NotifyAction): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.level !== 0) {
      obj.level = notificationLevelToJSON(message.level);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotifyAction>, I>>(base?: I): NotifyAction {
    return NotifyAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotifyAction>, I>>(object: I): NotifyAction {
    const message = createBaseNotifyAction();
    message.message = object.message ?? "";
    message.level = object.level ?? 0;
    return message;
  },
};

function createBaseValidateAction(): ValidateAction {
  return { validationRule: "", errorMessage: "" };
}

export const ValidateAction: MessageFns<ValidateAction> = {
  encode(message: ValidateAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validationRule !== "") {
      writer.uint32(10).string(message.validationRule);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validationRule = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateAction {
    return {
      validationRule: isSet(object.validationRule) ? globalThis.String(object.validationRule) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: ValidateAction): unknown {
    const obj: any = {};
    if (message.validationRule !== "") {
      obj.validationRule = message.validationRule;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateAction>, I>>(base?: I): ValidateAction {
    return ValidateAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateAction>, I>>(object: I): ValidateAction {
    const message = createBaseValidateAction();
    message.validationRule = object.validationRule ?? "";
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
